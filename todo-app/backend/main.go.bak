package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "strconv"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/jackc/pgx/v5/pgxpool"
)

type Task struct {
    ID        int    `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

func main() {
    // Build Postgres connection string from environment variables
    dbURL := fmt.Sprintf("postgres://%s:%s@%s:5432/%s",
        os.Getenv("DB_USER"),
        os.Getenv("DB_PASSWORD"),
        os.Getenv("DB_HOST"),
        os.Getenv("DB_NAME"),
    )

    // Connect to Postgres
    pool, err := pgxpool.New(context.Background(), dbURL)
    if err != nil {
        log.Fatal("Unable to connect to DB:", err)
    }
    defer pool.Close()

    // Initialize Gin
    r := gin.Default()

    // Enable CORS for all origins (good for development)
    r.Use(cors.Default())

    // GET /tasks → fetch all tasks from DB
    r.GET("/tasks", func(c *gin.Context) {
        rows, err := pool.Query(context.Background(), "SELECT id, title, completed FROM tasks")
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        defer rows.Close()

        var tasks []Task
        for rows.Next() {
            var t Task
            if err := rows.Scan(&t.ID, &t.Title, &t.Completed); err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }
            tasks = append(tasks, t)
        }

        c.JSON(http.StatusOK, gin.H{"tasks": tasks})
    })

    // POST /tasks → add a new task
    r.POST("/tasks", func(c *gin.Context) {
        var newTask Task
        if err := c.ShouldBindJSON(&newTask); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Insert into DB and get the new task ID
        err := pool.QueryRow(context.Background(),
            "INSERT INTO tasks (title, completed) VALUES ($1, $2) RETURNING id",
            newTask.Title, newTask.Completed).Scan(&newTask.ID)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusCreated, newTask)
    })

    // DELETE /tasks/:id → delete a task by ID
    r.DELETE("/tasks/:id", func(c *gin.Context) {
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid task ID"})
            return
        }

        cmdTag, err := pool.Exec(context.Background(), "DELETE FROM tasks WHERE id=$1", id)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        if cmdTag.RowsAffected() == 0 {
            c.JSON(http.StatusNotFound, gin.H{"error": "Task not found"})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "Task deleted"})
    })

    // Start server
    r.Run(":8080")
}

